defmodule GenReports do
  @moduledoc """
    Provides functions for creating a report that contains:
    total profit, profit by customer, orders frequency and
    customers frequency.
    Also provides a function for fetch the most frequently customer
    and the most asked dish.
  """

  alias GenReports.Parser

  @options ~w(profit_by_customer orders_frequency)a

  @doc """
    Receives a filename and converts the returned Stream to
    a list of maps where each map represents a line in the
    following format:
    [
      %{customer: 1, food: "pizza", price: 17},
      %{customer: 15, food: "burger", price: 25},
      %{customer: 19, food: "milkshake", price: 32},
      ...
    ]

    ## Parameters
      - filename: a valid csv file

    ## Examples
      iex> GenReports.build("report_test.csv")
      %{
        customers_frequency: %{
          "1" => 1,
          "2" => 1,
        },
        orders_frequency: %{
          "açaí" => 1,
          "churrasco" => 2,
        },
        profit_by_customer: %{
          "1" => 48,
          "10" => 36,
        },
        total_profit: 345
      }

  """
  def build(filename) when is_binary(filename) do
    Parser.parse_file(filename)
    |> Enum.to_list()
    |> List.flatten()
    |> build_report()
  end

  def build(_), do: {:error, "invalid file"}

  @doc """
    Receives a list of csv files and generates the report
    using Task module.

    ## Parameters
      - filenames: a list of csv filenames

    ## Examples
      iex> GenReports.build_many(["report_1.csv", "report_2.csv", "report_3.csv"])
      %{
        customers_frequency: %{
          "1" => 10150,
          "10" => 9855,
        orders_frequency: %{
          "açaí" => 37742,
          "churrasco" => 37650,
        },
        profit_by_customer: %{
          "1" => 278849,
          "10" => 268317,
        },
        total_profit: 8239413
      }
  """
  def build_many(filenames) when is_list(filenames) do
    case Enum.all?(filenames, &is_binary/1) do
      true ->
        result =
          filenames
          |> Task.async_stream(fn filename -> build(filename) end)
          |> Enum.to_list()

        customers_frequency = merge_reports(result, :customers_frequency)
        orders_frequency = merge_reports(result, :orders_frequency)
        profit_by_customer = merge_reports(result, :profit_by_customer)

        total_profit =
          Enum.reduce(result, 0, fn {:ok, map}, acc ->
            map[:total_profit] + acc
          end)

        Map.new(
          customers_frequency: customers_frequency,
          orders_frequency: orders_frequency,
          profit_by_customer: profit_by_customer,
          total_profit: total_profit
        )

      false ->
        {:error, "the filenames aren't binaries"}
    end
  end

  defp merge_reports(report, option) do
    for {:ok, map} <- report, reduce: %{} do
      acc ->
        Map.merge(acc, map[option], fn _key, value_1, value_2 ->
          value_1 + value_2
        end)
    end
  end

  @doc """
    Receives a report and options. If the options is valid,
    based in its value returns the most profitable customer, i.e
    the customer who spent more money, or returns the most
    ordered item from the menu.

    ## Parameters
      - report: a report generated by GenReports.build/1

    ## Options
      `:profit_by_customer` - returns the customer who spent more money.
      `:orders_frequency` - returns the most ordered item.

    ## Examples
      iex> GenReports.build("report_test.csv")
          |> GenReports.fetch_max(:profit_by_customer)
      {:ok, {"5", 49}}

      iex> GenReports.build("report_test.csv")
          |> GenReports.fetch_max(:orders_frequency)
      {:ok, {"esfirra", 3}}

      iex> GenReports.fetch_max("report_test.csv", :anything_invalid)
      {:error, "invalid options"}
  """
  def fetch_max(report, options) when options in @options do
    result = Enum.max_by(report[options], fn {_key, value} -> value end)
    {:ok, result}
  end

  def fetch_max(_filename, _options), do: {:error, "invalid option"}

  defp build_report(orders) do
    total_profit = calculate_total_profit(orders)
    profit_by_customer = calculate_profit_by_customer(orders)
    orders_frequency = calculate_orders_frequency(orders)
    customers_frequency = calculate_customers_frequency(orders)

    %{
      total_profit: total_profit,
      profit_by_customer: profit_by_customer,
      orders_frequency: orders_frequency,
      customers_frequency: customers_frequency
    }
  end

  defp calculate_total_profit(orders) do
    Enum.map(orders, fn order -> order.price end)
    |> Enum.sum()
  end

  defp calculate_profit_by_customer(orders) do
    Enum.reduce(orders, %{}, fn order, acc ->
      Map.update(acc, order.customer, order.price, fn item ->
        order.price + item
      end)
    end)
  end

  defp calculate_orders_frequency(orders) do
    Enum.map(orders, fn order -> order.food end)
    |> Enum.frequencies()
  end

  defp calculate_customers_frequency(orders) do
    Enum.map(orders, fn order -> order.customer end)
    |> Enum.frequencies()
  end
end
